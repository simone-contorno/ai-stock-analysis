# -*- coding: utf-8 -*-
"""
Module for generating PDF reports of financial analysis.

This module uses ReportLab to create a well-formatted PDF document
containing the financial analysis generated by TogetherAI.
Charts are generated using Matplotlib and then inserted into the PDF.
"""

import os
import logging
import datetime
import re
import tempfile
from pathlib import Path
from typing import Dict, Any, Optional, Tuple
from matplotlib.dates import DateFormatter
import pandas as pd

# ReportLab imports
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import cm
from reportlab.platypus import (
    SimpleDocTemplate,
    Paragraph,
    Spacer,
    Table,
    TableStyle,
    Image,
)

# Matplotlib imports
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator

# Logger configuration
logger = logging.getLogger(__name__)


class PDFGenerator:
    """Class for generating PDF reports of financial analysis."""

    def __init__(self):
        """Initializes the PDFGenerator class instance."""
        # We no longer create a separate reports folder
        # Reports will be saved in the same folder as the logs
        # The folder will be specified at report generation time
        # via the report_dir parameter in the generate_report function
        logger.info("PDF generator initialization completed")

    def generate_report(
        self,
        analysis_result: Dict[str, Any],
        stock_data: Optional[Dict[str, Any]] = None,
        prediction_data: Optional[str] = None,
        report_dir: Optional[Path] = None,
        filename: Optional[str] = None,
    ) -> Optional[str]:
        """Generates a PDF report of the financial analysis.
        
        Args:
            analysis_result: Dictionary containing the analysis result.
            stock_data: Dictionary containing financial data (optional).
            prediction_data: String containing prediction data or path to the predictions CSV file (optional).
            report_dir: Path to the folder in which to save the report (optional).
            filename: Name of the PDF file (optional).
            
        Returns:
            The path of the generated PDF file or None in case of error.
        """
        try:
            # Check that analysis_result is a valid dictionary
            if not isinstance(analysis_result, dict):
                logger.error(
                    f"Unable to generate the report: analysis_result is not a valid dictionary"
                )
                return None

            if not analysis_result.get("success", False):
                logger.error(f"Unable to generate the report: analysis not successful")
                return None

            # Extract information from the analysis
            company = analysis_result.get("company", "")
            symbol = analysis_result.get("symbol", "")
            recommendation = analysis_result.get("recommendation", "N/A")
            analysis_text = analysis_result.get("analysis", "")

            # Check that essential data is present
            if not symbol:
                logger.warning(
                    "Symbol not found in the analysis, using a default value"
                )
                symbol = "UNKNOWN"

            if not analysis_text:
                logger.warning(
                    "Analysis text not found, using a default message"
                )
                analysis_text = "No analysis available."

            # Determine the file path
            if report_dir is None:
                # If no folder is specified, generate an error
                # because we always want to save reports in the same folder as the logs
                logger.error(
                    f"Unable to generate the report: report_dir not specified"
                )
                return None

            # Use the specified folder
            if filename is None:
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"{symbol.upper()}_{timestamp}.pdf"
            filepath = report_dir / filename

            logger.info(f"Generating PDF report for {symbol} in {filepath}")

            # Create the PDF document
            doc = SimpleDocTemplate(
                str(filepath),
                pagesize=A4,
                rightMargin=2 * cm,
                leftMargin=2 * cm,
                topMargin=2 * cm,
                bottomMargin=2 * cm,
                title=f"Financial Analysis - {company} ({symbol})",
                author="Trading Portfolio Analyzer",
                subject=f"Financial Analysis for {company} ({symbol})",
                keywords="finance, trading, analysis, investments",
            )

            # Styles for the document
            styles = getSampleStyleSheet()
            # Check if styles already exist before adding them
            if "Title" not in styles:
                styles.add(
                    ParagraphStyle(
                        name="Title",
                        parent=styles["Heading1"],
                        fontSize=18,
                        alignment=1,  # Centered
                        spaceAfter=12,
                    )
                )
            if "Subtitle" not in styles:
                styles.add(
                    ParagraphStyle(
                        name="Subtitle",
                        parent=styles["Heading2"],
                        fontSize=14,
                        alignment=1,  # Centered
                        spaceAfter=10,
                    )
                )
            if "SectionTitle" not in styles:
                styles.add(
                    ParagraphStyle(
                        name="SectionTitle",
                        parent=styles["Heading3"],
                        fontSize=12,
                        spaceAfter=8,
                    )
                )
            if "Normal" not in styles:
                styles.add(
                    ParagraphStyle(
                        name="Normal",
                        parent=styles["Normal"],
                        fontSize=10,
                        spaceAfter=6,
                    )
                )
            # For Recommendation, always create a new style with the appropriate color
            recommendation_style_name = "Recommendation_" + recommendation.replace(
                " ", "_"
            )
            styles.add(
                ParagraphStyle(
                    name=recommendation_style_name,
                    parent=styles["Normal"],
                    fontSize=14,
                    alignment=1,  # Centered
                    textColor=self._get_recommendation_color(recommendation),
                    spaceAfter=10,
                    spaceBefore=10,
                    borderWidth=1,
                    borderColor=self._get_recommendation_color(recommendation),
                    borderPadding=10,
                    borderRadius=5,
                )
            )

            # Document elements
            elements = []

            # Title
            elements.append(Paragraph(f"Financial Analysis", styles["Title"]))
            elements.append(Paragraph(f"{company} ({symbol})", styles["Subtitle"]))
            elements.append(Spacer(1, 0.5 * cm))

            # Report date
            report_date = datetime.datetime.now().strftime("%d/%m/%Y %H:%M")
            elements.append(
                Paragraph(f"Report generated on: {report_date}", styles["Normal"])
            )
            elements.append(Spacer(1, 0.5 * cm))

            # Recommendation
            rec_emoji = self._get_recommendation_emoji(recommendation)
            elements.append(
                Paragraph(
                    f"{rec_emoji} RECOMMENDATION: {recommendation}",
                    styles[recommendation_style_name],
                )
            )
            elements.append(Spacer(1, 0.5 * cm))

            # Financial data
            if stock_data:
                elements.append(Paragraph("Financial Data", styles["SectionTitle"]))
                financial_data = self._create_financial_table(stock_data)
                elements.append(financial_data)
                elements.append(Spacer(1, 0.5 * cm))

                # Chart (if available)
                if "data" in stock_data:
                    # Add the section title 'Price Trend'
                    elements.append(Paragraph("Price Trend", styles["SectionTitle"]))
                    elements.append(Spacer(1, 0.2 * cm))
                    
                    # Pass the prediction file path or prediction text
                    chart = self._create_price_chart(stock_data, prediction_data, report_dir)
                    if chart:
                        elements.append(chart)
                        elements.append(Spacer(1, 0.5 * cm))

            # Detailed analysis
            elements.append(Paragraph("Detailed Analysis", styles["SectionTitle"]))

            # Split the analysis into paragraphs
            paragraphs = analysis_text.split("\n\n")
            for para in paragraphs:
                if para.strip():
                    # Check if the paragraph is a header (testo tra **)
                    import re

                    # Improved pattern to detect headers
                    header_match = re.match(r"^\s*\*\*(.*?)\*\*\s*$", para)
                    if header_match:
                        # It's a header, use the SectionTitle style
                        header_text = header_match.group(1).strip()
                        elements.append(Paragraph(header_text, styles["SectionTitle"]))
                    else:
                        # Search for headers within the paragraph
                        # Replace all patterns **text** with HTML bold format and header style
                        processed_para = re.sub(
                            r"\*\*(.*?)\*\*",
                            lambda m: f'<strong><font name="Helvetica-Bold" size="12" color="black">{m.group(1)}</font></strong>',
                            para,
                        )
                        # Improve bullet list formatting
                        processed_para = re.sub(
                            r"^- (.*)$",
                            lambda m: f"â€¢ {m.group(1)}",
                            processed_para,
                            flags=re.MULTILINE,
                        )
                        # It's a normal paragraph with possible internal headers
                        elements.append(
                            Paragraph(
                                processed_para.replace("\n", "<br/>"), styles["Normal"]
                            )
                        )
                    elements.append(Spacer(1, 0.3 * cm))

            # Generate the PDF
            logger.info(
                f"Attempting to generate the PDF with {len(elements)} elements"
            )
            try:
                doc.build(elements)
                logger.info(f"Call to doc.build completed successfully")

                # Check that the file was actually created
                if os.path.exists(str(filepath)):
                    logger.info(
                        f"PDF file verified: exists at {filepath} with size {os.path.getsize(str(filepath))} bytes"
                    )
                else:
                    logger.error(
                        f"PDF file not found after generation: {filepath}"
                    )
                    return None
            except Exception as e:
                logger.error(f"Specific error during doc.build: {str(e)}")
                return None

            logger.info(f"PDF report generated successfully: {filepath}")

            return str(filepath)

        except Exception as e:
            logger.error(f"Error during PDF report generation: {str(e)}")
            return None

    def _get_recommendation_color(self, recommendation: str) -> colors.Color:
        """Returns the color associated with the recommendation.

        Args:
            recommendation: The raccomandation (BUY, SELL, HOLD).

        Returns:
            The color associated with the recommendation.
        """
        recommendation = recommendation.upper()
        if recommendation == "BUY":
            return colors.green
        elif recommendation == "SELL":
            return colors.red
        elif recommendation == "HOLD":
            return colors.orange
        else:
            return colors.black

    def _get_recommendation_emoji(self, recommendation: str) -> str:
        """Returns the emoji associated with the recommendation.

        Args:
            recommendation: The recommendation (BUY, SELL, HOLD).

        Returns:
            The emoji associated with the recommendation.
        """
        recommendation = recommendation.upper()
        if recommendation == "BUY":
            return "ðŸŸ¢"
        elif recommendation == "SELL":
            return "ðŸ”´"
        elif recommendation == "HOLD":
            return "ðŸŸ¡"
        else:
            return "â“"

    def _create_financial_table(self, stock_data: Dict[str, Any]) -> Table:
        """Creates a table with financial data.

        Args:
            stock_data: Dictionary containing financial data.

        Returns:
            Table with financial data.
        """
        try:
            # Check that stock_data is a valid dictionary
            if not isinstance(stock_data, dict):
                logger.error("stock_data is not a valid dictionary")
                # Create an empty table with an error message
                data = [["Error", "Financial data not available"]]
                table = Table(data, colWidths=[8 * cm, 8 * cm])
                table.setStyle(
                    TableStyle(
                        [
                            ("BACKGROUND", (0, 0), (1, 0), colors.lightgrey),
                            ("TEXTCOLOR", (0, 0), (1, 0), colors.black),
                            ("ALIGN", (0, 0), (1, 0), "CENTER"),
                            ("FONTNAME", (0, 0), (1, 0), "Helvetica-Bold"),
                            ("GRID", (0, 0), (1, -1), 0.5, colors.grey),
                        ]
                    )
                )
                return table

            # Extract indicators with error handling
            try:
                value = stock_data.get("first_price", 0)
                first_price = (
                    float(value.iloc[0]) if hasattr(value, "iloc") else float(value)
                )
            except (ValueError, TypeError):
                logger.warning("Error converting first_price")
                first_price = 0.0

            try:
                value = stock_data.get("last_price", 0)
                last_price = (
                    float(value.iloc[0]) if hasattr(value, "iloc") else float(value)
                )
            except (ValueError, TypeError):
                logger.warning("Error converting last_price")
                last_price = 0.0

            try:
                value = stock_data.get("trend_pct", 0)
                trend_pct = (
                    float(value.iloc[0]) if hasattr(value, "iloc") else float(value)
                )
            except (ValueError, TypeError):
                logger.warning("Error converting trend_pct")
                trend_pct = 0.0

            try:
                value = stock_data.get("volatility", 0)
                volatility = (
                    float(value.iloc[0]) if hasattr(value, "iloc") else float(value)
                )
            except (ValueError, TypeError):
                logger.warning("Error converting volatility")
                volatility = 0.0

            try:
                value = stock_data.get("avg_volume", 0)
                avg_volume = (
                    float(value.iloc[0]) if hasattr(value, "iloc") else float(value)
                )
            except (ValueError, TypeError):
                logger.warning("Error converting avg_volume")
                avg_volume = 0.0

            try:
                value = stock_data.get("rsi", 0)
                rsi = float(value.iloc[0]) if hasattr(value, "iloc") else float(value)
            except (ValueError, TypeError):
                logger.warning("Error converting rsi")
                rsi = 0.0

            # Create the table data
            data = [
                ["Indicator", "Value"],
                ["Initial price", f"${first_price:.2f}"],
                ["Final price", f"${last_price:.2f}"],
                ["Percentage change", f"{trend_pct:.2f}%"],
                ["Annualized volatility", f"{volatility:.2f}%"],
                ["Average daily volume", f"{avg_volume:.0f}"],
                ["RSI (Relative Strength Index)", f"{rsi:.2f}"],
            ]

            # Create the table
            table = Table(data, colWidths=[8 * cm, 8 * cm])
            table.setStyle(
                TableStyle(
                    [
                        ("BACKGROUND", (0, 0), (1, 0), colors.lightgrey),
                        ("TEXTCOLOR", (0, 0), (1, 0), colors.black),
                        ("ALIGN", (0, 0), (1, 0), "CENTER"),
                        ("FONTNAME", (0, 0), (1, 0), "Helvetica-Bold"),
                        ("FONTSIZE", (0, 0), (1, 0), 12),
                        ("BOTTOMPADDING", (0, 0), (1, 0), 12),
                        ("BACKGROUND", (0, 1), (1, -1), colors.white),
                        ("TEXTCOLOR", (0, 1), (0, -1), colors.black),
                        ("ALIGN", (0, 1), (0, -1), "LEFT"),
                        ("TEXTCOLOR", (1, 1), (1, -1), colors.black),
                        ("ALIGN", (1, 1), (1, -1), "RIGHT"),
                        ("FONTNAME", (0, 1), (0, -1), "Helvetica-Bold"),
                        ("FONTNAME", (1, 1), (1, -1), "Helvetica"),
                        ("FONTSIZE", (0, 1), (1, -1), 10),
                        ("GRID", (0, 0), (1, -1), 0.5, colors.grey),
                        ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                        ("BOTTOMPADDING", (0, 1), (-1, -1), 6),
                        ("TOPPADDING", (0, 1), (-1, -1), 6),
                    ]
                )
            )

            return table

        except Exception as e:
            logger.error(
                f"Error creating the financial table: {str(e)}"
            )
            # Create an empty table with an error message in case of exception
            data = [["Error", "Unable to create the financial data table"]]
            table = Table(data, colWidths=[8 * cm, 8 * cm])
            table.setStyle(
                TableStyle(
                    [
                        ("BACKGROUND", (0, 0), (1, 0), colors.lightgrey),
                        ("TEXTCOLOR", (0, 0), (1, 0), colors.black),
                        ("ALIGN", (0, 0), (1, 0), "CENTER"),
                        ("FONTNAME", (0, 0), (1, 0), "Helvetica-Bold"),
                        ("GRID", (0, 0), (1, -1), 0.5, colors.grey),
                    ]
                )
            )
            return table

    def _create_matplotlib_chart(self, stock_data: Dict[str, Any], prediction_data: Optional[str] = None, report_dir: Optional[Path] = None) -> Tuple[str, bool]:
        """Creates a chart with Matplotlib and saves it in the report folder.

        Args:
            stock_data: Dictionary containing financial data.
            prediction_data: String containing prediction data.
            report_dir: Path to the folder in which to save the chart.

        Returns:
            Tuple containing the chart file path and a flag indicating if the file was successfully created.
        """
        try:
            # Check that stock_data is a valid dictionary
            if not isinstance(stock_data, dict):
                logger.error("stock_data is not a valid dictionary for chart creation")
                return "", False

            if "data" not in stock_data:
                logger.warning("'data' key not found in stock_data")
                return "", False

            if stock_data["data"] is None:
                logger.warning("stock_data['data'] is None")
                return "", False

            data = stock_data["data"]
            has_prediction = False
            transition_idx = None
            prediction_dates = []
            
            # Extract prediction data if available
            if prediction_data is not None:
                # Check if prediction_data is a file path
                if isinstance(prediction_data, str) and (os.path.isfile(prediction_data) or (prediction_data.endswith('.csv') and 'predictions_real.csv' in prediction_data)):
                    logger.info(f"Attempting to read prediction file: {prediction_data}")
                    try:
                        # Read the predictions CSV file
                        pred_df = pd.read_csv(prediction_data)
                        
                        # Check if 'date' column exists
                        if 'date' in pred_df.columns:
                            # Extract dates and predicted values
                            prediction_dates = pred_df['date'].tolist()
                            
                            # Extract predicted values (assuming they are in the second column)
                            if len(pred_df.columns) > 1:
                                predicted_values = pred_df.iloc[:, 1].tolist()
                            else:
                                # If only the date column exists, search for values in the text
                                pattern = r"\$(\d+\.?\d*)"
                                number_strings = re.findall(pattern, prediction_data)
                                predicted_values = [float(num_str) for num_str in number_strings] if number_strings else []
                        else:
                            # If there is no date column, use the regex pattern
                            pattern = r"\$(\d+\.?\d*)"
                            number_strings = re.findall(pattern, prediction_data)
                            predicted_values = [float(num_str) for num_str in number_strings] if number_strings else []
                            
                            # Generate fake dates starting from the last historical date
                            if hasattr(data.index, 'max') and isinstance(data.index, pd.DatetimeIndex):
                                last_date = data.index.max()
                                prediction_dates = [(last_date + pd.Timedelta(days=i+1)).strftime('%Y-%m-%d') 
                                                   for i in range(len(predicted_values))]
                    except Exception as e:
                        logger.warning(f"Error reading prediction file: {str(e)}")
                        # Fallback to previous method
                        pattern = r"\$(\d+\.?\d*)"
                        number_strings = re.findall(pattern, prediction_data)
                        predicted_values = [float(num_str) for num_str in number_strings] if number_strings else []
                else:
                    # Use previous method to extract values from text
                    pattern = r"\$(\d+\.?\d*)"
                    number_strings = re.findall(pattern, prediction_data)
                    predicted_values = [float(num_str) for num_str in number_strings] if number_strings else []
                
                # If we have predicted values, create the DataFrame
                if predicted_values:
                    # Extract first column name from data
                    data_first_column = data.columns[0] if hasattr(data, 'columns') else 'Close'
                    
                    # Save the transition index before concatenating
                    transition_idx = len(data)
                    
                    # Convert predicted data to pandas DataFrame
                    predicted_data = pd.DataFrame(predicted_values, columns=[data_first_column])
                    
                    # If we have prediction dates, set them as index
                    if prediction_dates and len(prediction_dates) == len(predicted_values):
                        predicted_data.index = pd.to_datetime(prediction_dates)
                    elif isinstance(data.index, pd.DatetimeIndex):
                        # Generate sequential dates starting from the last historical date
                        last_date = data.index[-1]
                        date_range = pd.date_range(start=last_date + pd.Timedelta(days=1), 
                                                 periods=len(predicted_values), freq='D')
                        predicted_data.index = date_range
                    
                    # Concatenate data and predicted_data
                    if isinstance(data.index, pd.DatetimeIndex) and isinstance(predicted_data.index, pd.DatetimeIndex):
                        # If both have datetime indices, preserve them
                        data = pd.concat([data, predicted_data])
                    else:
                        # Otherwise ignore indices
                        data = pd.concat([data, predicted_data], ignore_index=True)
                    
                    has_prediction = True

            # Check that data is a pandas DataFrame
            if not isinstance(data, pd.DataFrame):
                logger.error(f"Data is not a DataFrame, but {type(data)}")
                return "", False

            if len(data) < 2:
                logger.warning("Insufficient data to create a chart (less than 2 points)")
                return "", False

            # Check that 'Close' is present in the DataFrame
            if "Close" not in data.columns:
                logger.error("'Close' column not found in data")
                return "", False

            # Extract closing prices
            try:
                prices = data["Close"].to_numpy()
                if len(prices) < 2:
                    logger.warning("Price list is empty or insufficient")
                    return "", False
            except Exception as e:
                logger.error(f"Error extracting prices: {str(e)}")
                return "", False

            # Prepare dates for the X axis
            try:
                # Convert dates to datetime if not already
                if isinstance(data.index, pd.DatetimeIndex):
                    dates = data.index
                else:
                    # Try to convert index to dates
                    try:
                        dates = pd.to_datetime(data.index)
                    except:
                        # Use numeric indices as fallback
                        dates = pd.RangeIndex(len(prices))
                
                # Check that dates match prices
                if len(dates) != len(prices):
                    logger.warning(f"Number of dates ({len(dates)}) different from number of prices ({len(prices)})")
                    # Use numeric indices as fallback
                    dates = pd.RangeIndex(len(prices))
                    
                # Check that dates are in increasing order
                if isinstance(dates, pd.DatetimeIndex) and not dates.is_monotonic_increasing:
                    logger.warning("Dates are not in increasing order, sorting")
                    # Sort data by date
                    sorted_indices = dates.argsort()
                    dates = dates[sorted_indices]
                    prices = prices[sorted_indices]
                    
                # Check that the transition between historical data and predictions is correct
                if has_prediction and transition_idx is not None and isinstance(dates, pd.DatetimeIndex):
                    # Ensure prediction dates are consecutive to historical dates
                    if transition_idx > 0 and transition_idx < len(dates):
                        logger.info(f"Transition between historical data and predictions at index {transition_idx}")
                        logger.info(f"Last historical date: {dates[transition_idx-1]}")
                        logger.info(f"First prediction date: {dates[transition_idx]}")
            except Exception as e:
                logger.error(f"Error extracting dates: {str(e)}")
                # Use numeric indices as fallback
                dates = pd.RangeIndex(len(prices))

            # Calculate min and max values
            try:
                min_price = float(min(prices))
                max_price = float(max(prices))
                # Add a 5% margin
                price_range = max_price - min_price
                if price_range == 0:  # Avoid division by zero
                    min_price = min_price * 0.95 if min_price != 0 else -1
                    max_price = max_price * 1.05 if max_price != 0 else 1
                else:
                    min_price = min_price - (price_range * 0.05)
                    max_price = max_price + (price_range * 0.05)
            except Exception as e:
                logger.error(f"Error calculating min/max values: {str(e)}")
                # Use default values
                min_price = 0.0
                max_price = 100.0

            # Create a Matplotlib figure with dimensions optimized for PDF
            plt.figure(figsize=(8, 4), dpi=100)
            
            # Create the main chart
            ax = plt.subplot(111)
            
            # Draw the main price line
            if has_prediction and transition_idx is not None:
                # Draw historical data and predictions separately
                ax.plot(dates[:transition_idx], prices[:transition_idx], 'b-', linewidth=2, label='Historical Price')
                ax.plot(dates[transition_idx-1:], prices[transition_idx-1:], 'r--', linewidth=2, label='Prediction')
                
                # Add a marker at the transition point
                ax.plot(dates[transition_idx-1], prices[transition_idx-1], 'o', color='orange', markersize=8, label='Prediction Start')
            else:
                # Draw only historical data
                ax.plot(dates, prices, 'b-', linewidth=2, label='Price')
            
            # Highlight max and min points
            max_idx = prices.argmax()
            min_idx = prices.argmin()
            ax.plot(dates[max_idx], prices[max_idx], 'ro', markersize=8, label='Maximum')
            ax.plot(dates[min_idx], prices[min_idx], 'go', markersize=8, label='Minimum')
            
            # Configure axes
            ax.set_ylim(min_price, max_price)
            
            # Format X axis for dates
            if isinstance(dates, pd.DatetimeIndex):
                # Set date format on X axis
                date_format = DateFormatter('%d/%m')
                ax.xaxis.set_major_formatter(date_format)
                
                # Limit number of labels on X axis
                if len(dates) > 10:
                    ax.xaxis.set_major_locator(MaxNLocator(10, integer=True))
                    plt.xticks(rotation=45)
            else:
                # If no dates, still limit number of labels
                if len(dates) > 10:
                    step = max(1, len(dates) // 10)
                    plt.xticks(range(0, len(dates), step), rotation=45)
            
            # Add only axis labels (remove title as requested)
            plt.xlabel('Date', fontsize=10)
            plt.ylabel('Price ($)', fontsize=10)
            
            # Add grid for readability
            plt.grid(True, linestyle='--', alpha=0.7)
            
            # Add legend
            plt.legend(loc='best', frameon=True, fancybox=True, shadow=True)
            
            # Add period information
            if isinstance(dates, pd.DatetimeIndex):
                start_date = dates[0].strftime('%d/%m/%Y')
                end_date = dates[-1].strftime('%d/%m/%Y')
                period_text = f"Period: {start_date} - {end_date}"
            else:
                period_text = "Period: N/A"
                
            plt.figtext(0.5, 0.01, period_text, ha='center', fontsize=8)
            
            # Add min/max info between title and chart, side by side
            min_text = f"Min: ${min_price:.2f}"
            max_text = f"Max: ${max_price:.2f}"
            # Place values side by side with spacing
            plt.figtext(0.35, 0.92, max_text, ha='center', fontsize=9, bbox=dict(facecolor='white', alpha=0.8, boxstyle='round,pad=0.3'))
            plt.figtext(0.65, 0.92, min_text, ha='center', fontsize=9, bbox=dict(facecolor='white', alpha=0.8, boxstyle='round,pad=0.3'))
            
            # Increase space between title and chart
            plt.subplots_adjust(top=0.85)
            
            # Optimize layout
            plt.tight_layout(pad=2.0)
            
            # Save the chart in the report folder
            if report_dir is None:
                # If no folder specified, use a temp folder
                temp_dir = tempfile.gettempdir()
                chart_filename = f"chart_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                chart_path = os.path.join(temp_dir, chart_filename)
            else:
                # Use the specified report folder
                chart_filename = f"chart_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                chart_path = os.path.join(str(report_dir), chart_filename)
            
            plt.savefig(chart_path, format='png', bbox_inches='tight')
            plt.close()
            
            logger.info(f"Matplotlib chart saved at: {chart_path}")
            return chart_path, True
            
        except Exception as e:
            logger.error(f"Error during Matplotlib chart creation: {str(e)}")
            return "", False

    def _create_price_chart(self, stock_data: Dict[str, Any], prediction_data: Optional[str]=None, report_dir: Optional[Path]=None) -> Optional[Image]:
        """Creates a price trend chart using Matplotlib and inserts it into the PDF.

        Args:
            stock_data: Dictionary containing financial data.
            prediction_data: String containing prediction data or path to predictions CSV file.
            report_dir: Path to the folder where to save the chart.

        Returns:
            ReportLab Image object containing the chart or None in case of error.
        """
        try:
            # Generate the chart with Matplotlib and get the file path
            chart_path, success = self._create_matplotlib_chart(stock_data, prediction_data, report_dir)
            
            if not success or not chart_path:
                logger.error("Unable to create chart with Matplotlib")
                return None
                
            # Create a ReportLab Image object from the temp file
            chart_image = Image(chart_path, width=450, height=250)
            
            # Set automatic removal of temporary file after use
            # This is done by registering a cleanup function that will be called when the Image object is destroyed
            def cleanup_temp_file(path=chart_path):
                try:
                    if os.path.exists(path):
                        os.unlink(path)
                        logger.debug(f"Temporary file removed: {path}")
                except Exception as e:
                    logger.warning(f"Unable to remove temporary file {path}: {str(e)}")
            
            # Register the cleanup function as an attribute of the Image object
            chart_image._cleanup = cleanup_temp_file
            
            logger.info("Matplotlib chart successfully created and inserted into the PDF")
            return chart_image
            
        except Exception as e:
            logger.error(f"Error during chart creation: {str(e)}")
            return None
